#
# Ronin Exploits - A Ruby library for Ronin that provides exploitation and
# payload crafting functionality.
#
# Copyright (c) 2007-2011 Hal Brodigan (postmodern.mod3 at gmail.com)
#
# This file is part of Ronin Exploits.
#
# Ronin is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ronin is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ronin.  If not, see <http://www.gnu.org/licenses/>
#

require 'ronin/post_exploitation/resources'
require 'ronin/post_exploitation/exceptions/unknown_resource'
require 'ronin/post_exploitation/class_methods'
require 'ronin/extensions/meta'

require 'set'

module Ronin
  #
  # Classes or objects can include {PostExploitation} so they can declare
  # what specific resources they leverage. To leverage a resource the
  # class or object must first declare the resource:
  #
  #     leverage :fs
  #
  # Objects will then gain a `#fs` method, which will return an
  # {PostExploitation::Resources::FS} object. {PostExploitation::Resources}
  # contains classes that provide convience methods for leveraging
  # resources. In turn, these convience methods call methods defined in the
  # object which leverages the Resource. For example,
  # the {PostExploitation::Resources::FS#mkdir} method relies on the
  # `fs_mkdir` method to handle the making of the directory:
  #
  #       leverages :fs
  #       # ...
  #
  #       #
  #       # Injects a `mkdir` command.
  #       #
  #       def fs_mkdir(path)
  #         inject_command("; mkdir #{path}; ")
  #       end
  #
  #     # ...
  #     obj.fs.mkdir('.temp')
  #
  # @since 1.0.0
  #
  module PostExploitation
    def self.included(base)
      base.send :extend, ClassMethods
    end

    #
    # The Resources to be leveraged.
    #
    # @return [Set<Symbol>]
    #   The service names.
    #
    def leverages
      @leverages ||= self.class.leverages.clone
    end

    #
    # Determines if the object leverages the specified resource.
    #
    # @param [Symbol] name
    #   The resource name.
    #
    # @return [Boolean]
    #   Specifies whether the object leverages the specified resource.
    #
    def leverages?(name)
      self.leverages.include?(name.to_sym)
    end

    #
    # The leveraged resources.
    #
    # @return [Hash{Symbol => Resource}]
    #   The leveraged resources.
    #
    def leveraged_resources
      @leveraged ||= Hash.new do |hash,key| 
        if self.leverages?(key)
          hash[key] = leveraged_resource(key)
        end
      end
    end

    protected

    #
    # Loads and creates a new leveraged resource.
    #
    # @param [Symbol] name
    #   The resource to load.
    #
    # @return [Resource]
    #   The leveraged resource.
    #
    def leveraged_resource(name)
      name = name.to_sym

      unless (resource = Resources.require_const(name))
        raise(UnknownResource,"unknown resource for #{name}")
      end

      return resource.new(self)
    end

    #
    # Defines a leveraged resource.
    #
    # @param [Symbol] name
    #   The resource to leverage.
    #
    # @return [Resource]
    #   The leveraged resource.
    #
    # @raise [UnknownResource]
    #   The resource class could not be found.
    #
    def leverage(name)
      name = name.to_sym

      unless self.respond_to?(name)
        # define a getter method, if it was not defined by the class
        self.meta_def(name) { self.leveraged_resources[name] }
      end

      self.leverages << name
    end
  end
end
